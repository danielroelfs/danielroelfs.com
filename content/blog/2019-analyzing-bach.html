---
draft: true
title: Analyzing Bach
author: Daniel Roelfs
date: '2019-11-24'
slug: analyzing-bach
categories:
  - coding
tags:
  - ggplot
  - R
  - Bach
description: 'Analyzing Bach'
thumbnail: images/avatar.png
---



<style>
@import url('https://fonts.googleapis.com/css?family=IM+Fell+English|IM+Fell+English+SC&display=swap');
body{
  background-color: #FFFFF0;
}

h1 {
  font-family: 'IM Fell English', serif;
}
h2,h3,h4,h5,h6 {
  font-family: 'IM Fell English', serif;
}
.post-title {
  font-family: 'IM Fell English SC', serif;
  font-size: 6rem;
}
</style>
<!-- ******************************************************************* -->
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>A little while ago I was watching a documentary series on Dutch television about one of the most beloved composers in the Netherlands: Johann Sebastian Bach. I had</p>
<!-- ******************************************************************* -->
</div>
<div id="collecting-the-data" class="section level2">
<h2>Collecting the data</h2>
<p>In my search of a dataset, I found this old website, looking like it last got a major update in 2003, made by what appeared to be a Bach enthousiast called Bryen Travis. This website contained a list of all works by Bach, with some information about each of them. The website listed a few options, an online browser, a pdf containing slimmed down entries, and two files that I couldn’t get to work, presumably because they were in a format that have presumably become depracated since they were uploaded back in 1996, when the website was created. I could have used the pdf, but since it contained only the BWV number, the title of the piece, and the setting, I had to scrape the data I wanted from the website directly.</p>
</div>
<div id="list-of-bwvs" class="section level2">
<h2>List of BWVs</h2>
<p>The website browser contains an index which lists the links to each BWV. Each BWV has its own html page in a subfolder. Thankfully, the html pages were referred by BWV number, and not title, this made my next job a lot easier. I decided to obtain the list of available BWVs from the index page. There in total 1128 BWVs since a new piece was attributed to Bach in 2008. However, the website doesn’t list all of them. The largest number is 1120, but there’s some numbers missing (e.g. 141 and 142), and some duplicate links too (e.g. 147). Therefore I couldn’t just loop from 1 through 1120, but had to extract just the numbers available. The code for this is definitely a bit messy, but let’s have a look anyway. In short, I read the html page as a character vecetor. I get all instances when there’s a link (identified by the <code>href</code> tag), convert it from a list to a vector, extract only the unique values, and then select only the links where there’s numbers in front of a <code>.html</code> string. I convert it to a character string again, and extract now only the numbers. I’m 99% sure that there is a more efficient way to do this, but this was the best I could think of.</p>
<pre class="r"><code>index_url &lt;- &quot;http://www.bachcentral.com/BWV/index.html&quot;
BWVs &lt;- paste(readLines(index_url), collapse = &quot;\n&quot;) %&gt;%
  str_match_all(&quot;&lt;a href=\&quot;(.*?)\&quot;&quot;) %&gt;%
  unlist() %&gt;%
  unique() %&gt;%
  str_extract_all(&quot;[0-9]+.html&quot;) %&gt;%
  unlist() %&gt;%
  unique() %&gt;%
  str_extract_all(&quot;[0-9]+&quot;) %&gt;%
  as.character()
str(BWVs)</code></pre>
<pre><code>##  chr [1:1075] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ...</code></pre>
<p>I now have a list of 1075 numbers, corresponding to BWV numbers of which this website has an entry. The next thing I needed to do now was loop over these numbers, navigate to each of the webpages corresponding to that link, and scrape all 1075 webpages individually. This takes a little bit of time, but luckily the author of the pages was very consistent in the setup, so I didn’t need to build in fail-safes or condititions to account for irregularities. Before we’ll do that, I first initialized a data frame with the correct size for speed. I added the column names for convenience too.</p>
<pre class="r"><code>col_names &lt;- c(&quot;Title&quot;, &quot;Subtitle_and_notes&quot;, 
               &quot;BWV&quot;, &quot;BWV_epifix&quot;, &quot;CLC_BWV_w_epifix&quot;, &quot;belongs after&quot;, 
               &quot;voices_instruments&quot;, 
               &quot;category1&quot;, &quot;category2&quot;, &quot;category3&quot;,
               &quot;cantate_cat1&quot;, &quot;cantate_cat2&quot;)

scraped_data &lt;- data.frame(matrix(ncol = 12, nrow = length(BWVs)))
colnames(scraped_data) &lt;- col_names</code></pre>
</div>
<div id="scraping-the-data" class="section level2">
<h2>Scraping the data</h2>
<p>We now have a variable of the same dimensions and column names as I’ll scrape from the website. Now it’s time to loop through the webpages and collect the data. Each webpage contains what looks like a table, but within the table it’s bulleted lists (denoted as <code>ul</code>). This might just be how html builds up tables, but I thought it was a bit strange. Nonetheless, it provided me with an easy hook to grab the values. I remove all the white spaces (<code>\t</code>), and each new line was denoted by a <code>\n</code>, which I used to split the strings into separate values. The andvantage of this approach is that when a field is empty, it will still occupy an element in the character array. Then all I needed to do to obtain the values is take every second element and add it as a row to the data frame I created earlier. Now I have a dataset containing the values from all of the 1075 webpages, with which I was quite pleased.</p>
<pre class="r"><code>for (i in 1:length(BWVs)) {
  
  print(sprintf(&quot;Scraping data for BWV %s&quot;, BWVs[i]))
  
  url &lt;- sprintf(&quot;http://www.bachcentral.com/BWV/%s.html&quot;, BWVs[i])
  webpage &lt;- read_html(url)
  
  text &lt;- webpage %&gt;%
    html_nodes(&quot;ul&quot;) %&gt;%
    html_text() %&gt;%
    gsub(&#39;[\t]&#39;, &#39;&#39;, .) %&gt;%
    strsplit(., &quot;\\n&quot;) %&gt;%
    unlist()
  
  values &lt;- text[seq(2,length(text),2)]
  
  scraped_data[i, ] &lt;- values
  
}</code></pre>
<p>With this, I achieved the first goal I had for this little project, which was to find or create a dataset on Bach. Let’s see what it looks like:</p>
<pre class="r"><code>str(scraped_data)</code></pre>
<pre><code>## &#39;data.frame&#39;:    1075 obs. of  12 variables:
##  $ Title             : chr  &quot;Wie schön leuchtet der Morgenstern&quot; &quot;Ach Gott, von Himmel sieh darein&quot; &quot;Ach Gott, wie manches Herzeleid&quot; &quot;Christ lag in Todes Banden&quot; ...
##  $ Subtitle_and_notes: chr  &quot;Kantate am Fest Mariae Verkündigung (Festo annuntiationis Mariae)&quot; &quot;Kantate am zweiten Sonntag nach Trinitatis (Dominica 2 post Trinitatis)&quot; &quot;Kantate am zweiten Sonntag nach Epiphanias (Dominica 2 post Epiphanias)&quot; &quot;Kantate am Osterfest (Feria Paschatos)&quot; ...
##  $ BWV               : chr  &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##  $ BWV_epifix        : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ CLC_BWV_w_epifix  : chr  &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##  $ belongs after     : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ voices_instruments: chr  &quot;Soli: S, T, B. Chor: S, A, T, B. Instr.: Corno I, II; Ob. da caccia I, II; Viol. conc. I, II; Viol. rip. I, II; Vla.; Cont.&quot; &quot;Soli: A, T, B. Chor: S, A, T, B. Instr.: Tromb. I - IV; Ob. I, II; Viol. I, II; Vla.; Cont.&quot; &quot;Soli: S, A, T, B. Chor: S, A, T, B. Instr.: Corno; Tromb.; Ob. d&#39;amore I, II; Viol. I, II; Vla.; Cont.&quot; &quot;Soli: S, A, T, B. Chor: S, A, T, B. Instr.: Cornetto; Tromb. I, II, III; Viol. I, II; Vla. I, II; Cont.&quot; ...
##  $ category1         : chr  &quot;Vokalwerke&quot; &quot;Vokalwerke&quot; &quot;Vokalwerke&quot; &quot;Vokalwerke&quot; ...
##  $ category2         : chr  &quot;Kantaten&quot; &quot;Kantaten&quot; &quot;Kantaten&quot; &quot;Kantaten&quot; ...
##  $ category3         : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ cantate_cat1      : chr  &quot;A. Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; &quot;A. Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; &quot;A. Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; &quot;A. Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; ...
##  $ cantate_cat2      : chr  &quot;Mariae Verkundigung&quot; &quot;2. Sonntag nach Trinitatis&quot; &quot;2. Sonntag nach Epiphanias&quot; &quot;1. Osterfesttag&quot; ...</code></pre>
<p>All columns are currently character arrays, and this is appropriate for most of them. Although I think the BWV number alone could be a numeric array. Also, some columns are still a bit awkward. This is why I moved on to do another important and satisfying part, cleaning the data.</p>
</div>
<div id="cleaning-the-data" class="section level2">
<h2>Cleaning the data</h2>
<p>The character arrays are appropriate, but for further analyes I’d prefer to make at least the categories explicitely factorial. Then I’ll also rename awkwardly named columns, and reorder the columns to start with the BWV instead of the number title.</p>
<pre class="r"><code>data &lt;- scraped_data %&gt;%
  mutate(BWV = as.numeric(BWV),
         category1 = factor(category1),
         category2 = factor(category2),
         category3 = factor(category3),
         cantate_cat1 = substring(cantate_cat1,4),
         CLC_BWV_w_epifix = str_replace(CLC_BWV_w_epifix, &quot; &quot;, &quot;&quot;)) %&gt;%
  rename(BWV_w_epifix = CLC_BWV_w_epifix) %&gt;%
  select(BWV, BWV_epifix, BWV_w_epifix, everything())
str(data)</code></pre>
<pre><code>## &#39;data.frame&#39;:    1075 obs. of  12 variables:
##  $ BWV               : num  1 2 3 4 5 6 7 8 9 10 ...
##  $ BWV_epifix        : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ BWV_w_epifix      : chr  &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##  $ Title             : chr  &quot;Wie schön leuchtet der Morgenstern&quot; &quot;Ach Gott, von Himmel sieh darein&quot; &quot;Ach Gott, wie manches Herzeleid&quot; &quot;Christ lag in Todes Banden&quot; ...
##  $ Subtitle_and_notes: chr  &quot;Kantate am Fest Mariae Verkündigung (Festo annuntiationis Mariae)&quot; &quot;Kantate am zweiten Sonntag nach Trinitatis (Dominica 2 post Trinitatis)&quot; &quot;Kantate am zweiten Sonntag nach Epiphanias (Dominica 2 post Epiphanias)&quot; &quot;Kantate am Osterfest (Feria Paschatos)&quot; ...
##  $ belongs after     : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ voices_instruments: chr  &quot;Soli: S, T, B. Chor: S, A, T, B. Instr.: Corno I, II; Ob. da caccia I, II; Viol. conc. I, II; Viol. rip. I, II; Vla.; Cont.&quot; &quot;Soli: A, T, B. Chor: S, A, T, B. Instr.: Tromb. I - IV; Ob. I, II; Viol. I, II; Vla.; Cont.&quot; &quot;Soli: S, A, T, B. Chor: S, A, T, B. Instr.: Corno; Tromb.; Ob. d&#39;amore I, II; Viol. I, II; Vla.; Cont.&quot; &quot;Soli: S, A, T, B. Chor: S, A, T, B. Instr.: Cornetto; Tromb. I, II, III; Viol. I, II; Vla. I, II; Cont.&quot; ...
##  $ category1         : Factor w/ 2 levels &quot;Instrumentalwerke&quot;,..: 2 2 2 2 2 2 2 2 2 2 ...
##  $ category2         : Factor w/ 15 levels &quot;Kammermusik&quot;,..: 3 3 3 3 3 3 3 3 3 3 ...
##  $ category3         : Factor w/ 26 levels &quot;&quot;,&quot;Choralbearbeitungen&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ cantate_cat1      : chr  &quot;Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; &quot;Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; &quot;Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; &quot;Geistliche Kantaten an der Sonn- und Festtagen des Kirchenjahres&quot; ...
##  $ cantate_cat2      : chr  &quot;Mariae Verkundigung&quot; &quot;2. Sonntag nach Trinitatis&quot; &quot;2. Sonntag nach Epiphanias&quot; &quot;1. Osterfesttag&quot; ...</code></pre>
<p>Now we have this data, we can do some descriptive visualizations of the data. Over time I hope I can dive into the setting (<code>voices_instruments</code>) and disect that, but for now I’ll keep it simple and just do some descriptives.</p>
</div>
<div id="visualizations" class="section level2">
<h2>Visualizations</h2>
<p>The first descritive I wanted to see was what kind of work Bach wrote and in what numbers.</p>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-12-1.png" width="1152" style="display: block; margin: auto;" /></p>
</div>
<div id="scraping-wikipedia" class="section level2">
<h2>Scraping Wikipedia</h2>
<p>The dataset I just created was comprehensive and clean, but it didn’t contain any information about the musical properties other than the setting. Luckily Wikipedia has a page listing the compositions by Bach too (because of course Wikipedia does). This page contains approximate dates on each composition, as well as the key it was written in. I’m going to scrape this webpage too. The setup of this page was somewhat simpler, so scraping it was slightly simpler.</p>
<pre class="r"><code>url &lt;- &quot;https://en.wikipedia.org/wiki/List_of_compositions_by_Johann_Sebastian_Bach&quot;
webpage &lt;- read_html(url)

wikitext &lt;- webpage %&gt;%
  html_nodes(xpath=&#39;//*[@id=&quot;TOP&quot;]&#39;) %&gt;%
  html_table() %&gt;%
  as.data.frame()</code></pre>
<p>Then I cleaned the data somewhat and extracted the number from the BWV columns.</p>
<pre class="r"><code>wikidata &lt;- wikitext %&gt;%
  rename(BWV_full = BWV) %&gt;%
  #mutate(BWV = parse_number(BWV_full))
  mutate(BWV = sub(&#39;.*(\\d{3}).*&#39;, &#39;\\1&#39;, BWV_full),
         BWV = parse_integer(BWV)) %&gt;%
  filter(!rev(duplicated(rev(BWV))))</code></pre>
<p>Then I merged the data. I lost a number of compositions in the process, but I was okay with it, mostly because it took me too much time and effort to try and fix it. Hurray for laziness. I extracted the year from the slightly messy <code>Date</code> column. Some strings in this column contain two dates, one for the first compilation and one for the date of completion. I extracted the last number, the year of completion.</p>
<pre class="r"><code>merged_data &lt;- merge(data, wikidata, by = &quot;BWV&quot;) %&gt;%
  mutate(year = sub(&#39;.*(\\d{4}).*&#39;, &#39;\\1&#39;, Date),
         year = as.numeric(year),
         year = ifelse(year &gt; 1750, NA, year),
         age = year - 1685)</code></pre>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-17-1.png" width="1152" style="display: block; margin: auto;" /></p>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-19-1.png" width="1152" style="display: block; margin: auto;" /></p>
</div>
<div id="places-bach-lived-and-worked" class="section level2">
<h2>Places Bach lived and worked</h2>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-21-1.png" width="1152" style="display: block; margin: auto;" /></p>
<p><img src="/blog/2019-analyzing-bach_files/figure-html/unnamed-chunk-22-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="future-plans" class="section level2">
<h2>Future plans</h2>
</div>
