---
title: Plotting Star Destroyers in R
author: Daniel Roelfs
date: '2020-04-17'
slug: Plotting Star Destroyers in R
categories:
  - coding
tags:
  - ggplot
  - R
description: 'Plotting Star Destroyers in R'
thumbnail: images/avatar.png
---



<script src="//yihui.org/js/math-code.js"></script>
<script async
src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p>Most people in my environment know R as the quintessential tool for statistical analysis and data visualization. There’s plenty of tutorials and discussions online about how to go about either. But one important aspect that is noticeably lacking is a discussion about R’s ability to simulate scenes from Star Wars. Today, we’ll set this straight. At the same time we’ll also explore how to incorporate a mathematical formula with a set of simple rules into R. This post is an R implementation of a Numberphile video from Brady Haran with Neil Sloane where they discuss the mathematics behind fun graphs. It’s a great video, you can check it out <a href="https://youtu.be/o8c4uYnnNnc"><strong>here</strong></a>.</p>
<p>We’ll use a formula called the <em>balanced ternary enumeration</em>. The game is to convert a decimal number to base 3, or the ternary. The best way to describe the ternary is to put it next to the binary. Binary (or base 2) is perhaps more widely understood. I don’t actually know of any use of the ternary outside of these hypothetical mathematical problems. Octadecimal and hexadecimal are used sometimes. The latter is used for instance in defining colors in computers.</p>
</div>
<div id="lets-start-with-counting" class="section level3">
<h3>Let’s start with counting</h3>
<p>Let’s start at the very basics. Like primary school basic. In the decimal system, we could from 1 to 9 and then add a digit and start from 1 again ([1 2 3 … 8 9 10 11 12 … 20 21 …]) This system likely comes from the fact that humans have 10 fingers. (Interestingly, the Maya used a system with base 20, because they used their toes to count also, and there’s a Native American tribe in California that uses base 8 because they use the space between fingers to count.) Computers use binary (base 2) because a pin or electrical signal can either be on or off. This means that there’s two values available to denote a number, either 0 or 1. In this system each digit represents the double of the previous, starting from 1. So the first digit represents 1, the second 2, the third 4, the fourth 8 and so on. So the number 5 is made from adding 4 and 1 together, so the binary representation of the number 4 is 100, and 5 is 101. The number 6 is denoted as 110, and so on.
In a ternary system, this same principle applies as in the binary system, except digits now increase by a factor of 3. The first digit represents 1, the second 3, the third9 and so on. This also means that there’s three possible values to denote a number, 0, 1, or 2. To illustrate how decimal numbers are represented in the binary and ternary system, look at the table below.</p>
<table>
<thead>
<tr class="header">
<th align="center">Decimal</th>
<th align="center">Binary</th>
<th align="center">Ternary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">10</td>
<td align="center">2</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">11</td>
<td align="center">10</td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center">100</td>
<td align="center">11</td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center">101</td>
<td align="center">12</td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center">110</td>
<td align="center">20</td>
</tr>
<tr class="odd">
<td align="center">7</td>
<td align="center">111</td>
<td align="center">21</td>
</tr>
<tr class="even">
<td align="center">8</td>
<td align="center">1000</td>
<td align="center">22</td>
</tr>
<tr class="odd">
<td align="center">9</td>
<td align="center">1001</td>
<td align="center">100</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">1010</td>
<td align="center">101</td>
</tr>
<tr class="odd">
<td align="center">11</td>
<td align="center">1011</td>
<td align="center">102</td>
</tr>
<tr class="even">
<td align="center">12</td>
<td align="center">1100</td>
<td align="center">110</td>
</tr>
<tr class="odd">
<td align="center">13</td>
<td align="center">1101</td>
<td align="center">111</td>
</tr>
<tr class="even">
<td align="center">14</td>
<td align="center">1110</td>
<td align="center">112</td>
</tr>
<tr class="odd">
<td align="center">15</td>
<td align="center">1111</td>
<td align="center">120</td>
</tr>
<tr class="even">
<td align="center">16</td>
<td align="center">10000</td>
<td align="center">121</td>
</tr>
<tr class="odd">
<td align="center">17</td>
<td align="center">10001</td>
<td align="center">122</td>
</tr>
<tr class="even">
<td align="center">18</td>
<td align="center">10010</td>
<td align="center">200</td>
</tr>
<tr class="odd">
<td align="center">19</td>
<td align="center">10011</td>
<td align="center">201</td>
</tr>
<tr class="even">
<td align="center">20</td>
<td align="center">10100</td>
<td align="center">202</td>
</tr>
<tr class="odd">
<td align="center">21</td>
<td align="center">10101</td>
<td align="center">210</td>
</tr>
</tbody>
</table>
</div>
<div id="moving-numbers-between-systems" class="section level3">
<h3>Moving numbers between systems</h3>
<p>Unlike MATLAB (<code>dec2bin()</code>) or Python (<code>bin()</code>), R doesn’t have a natural built-in function to convert decimal numbers to binary (unless you want to use the weird <code>intToBits()</code> function). So I wrote a function instead which continually appends the modulus while it loops through the digits of the numbers by dividing it in half continuously. The modulus is what is left after division of number x by number y. Let’s take the number 13 as an example. In the first loop, the modulus of 13 when divided by 2 is 1. So that goes in the first position, representing value 1. The next digit in the binary system represents the value 2. So we divide our initial value by 2 (and round it to the lower integer it in case we get decimal points) and take the modulus again. So the modulus of 6 when divided by 2 is 0. So that’s the second digit. The next loop will result in another 1 (<span class="math inline">\(x = 6; \lfloor x/2 \rfloor\ mod\ 2 = 1\)</span>, <span class="math inline">\(\lfloor x \rfloor\)</span> represents rounding <span class="math inline">\(x\)</span> to the nearest lower integer, i.e. floor), and then in the final loop, we take half of 3 and take the modulus again (<span class="math inline">\(x = 3; \lfloor x/2 \rfloor\ mod\ 2 = 1\)</span>). After this, when we floor 0.5, the loop cancels since from here on it will just produce an infinite amount of leading zero’s. This function now gives us the value 1101, which corresponds to the table above. The code for this function looks like this:</p>
<pre class="r"><code>ConvertToBinary &lt;- function(x) {
  out &lt;- mod &lt;- NULL
  while (x &gt; 0 | is.null(mod)) {
    mod &lt;- x %% 2
    out &lt;- paste0(mod, out)
    x &lt;- floor(x / 2)
  }
  return(out)
}</code></pre>
<p>Let’s run this function:</p>
<pre class="r"><code>ConvertToBinary(13)</code></pre>
<pre><code>## [1] &quot;1101&quot;</code></pre>
<p>Now in this function we’ve hard coded that the base is 2, but this code works for any base up to base 10 with just a simple rewrite of the code. If we go higher, e.g. base 11, we are going to have to start using letters to represent values, which I’m too lazy to implement right now. We can specify the base as an input variable.</p>
<pre class="r"><code>ConvertToBase &lt;- function(x, base = NULL) {
  if (base &gt; 10) {
    stop(&quot;Function not defined for bases higher than 10&quot;)
  }
  out &lt;- mod &lt;- NULL
  while (x &gt; 0 | is.null(mod)) {
    mod &lt;- x %% base
    out &lt;- paste0(mod, out)
    x &lt;- floor(x / base)
  }
  return(out)
}</code></pre>
<p>These functions only accepts a single value, but to get the transformed value for a vector of integers we can use the <code>map()</code> function from <code>{purrr}</code>. <code>map()</code> as default outputs a list, but we can also ask for a character vector. We can then convert a number of values to binary like this:</p>
<pre class="r"><code>example_vector &lt;- c(0:4,10,13,22,50,75,100)
map_chr(example_vector, ConvertToBinary)</code></pre>
<pre><code>##  [1] &quot;0&quot;       &quot;1&quot;       &quot;10&quot;      &quot;11&quot;      &quot;100&quot;     &quot;1010&quot;    &quot;1101&quot;   
##  [8] &quot;10110&quot;   &quot;110010&quot;  &quot;1001011&quot; &quot;1100100&quot;</code></pre>
<pre class="r"><code>map_chr(example_vector, base = 3, ConvertToBase)</code></pre>
<pre><code>##  [1] &quot;0&quot;     &quot;1&quot;     &quot;2&quot;     &quot;10&quot;    &quot;11&quot;    &quot;101&quot;   &quot;111&quot;   &quot;211&quot;   &quot;1212&quot; 
## [10] &quot;2210&quot;  &quot;10201&quot;</code></pre>
</div>
<div id="the-rules-of-the-game" class="section level3">
<h3>The rules of the game</h3>
<p>Okay, so here’s the rules of the <em>balanced ternary enumeration</em> game We write all integers in base 3, and replace all digits that are 2 with -1 and then sum the outcome. Let’s look at the first ten numbers in ternary:</p>
<pre class="r"><code>map_chr(seq(10), base = 3, ConvertToBase)</code></pre>
<pre><code>##  [1] &quot;1&quot;   &quot;2&quot;   &quot;10&quot;  &quot;11&quot;  &quot;12&quot;  &quot;20&quot;  &quot;21&quot;  &quot;22&quot;  &quot;100&quot; &quot;101&quot;</code></pre>
<p>So in this sequence, we would replace the second value (<code>2</code>) with <code>-1</code>, which makes -1. We would also replace the second digit of fifth value (<code>12</code>), which makes [1,-1], which, when we add these numbers up , makes 2. This because 1 in the first position denotes value 3, minus 1 in the second position (representing 1) makes 2 since <span class="math inline">\((3*1) + (1*-1) = 2\)</span>. The next value (<code>20</code>) has a 2 in the first position, replace this with -1 makes [-1,0]. The first position denotes 3, minus 0 in the second position, makes -3 since <span class="math inline">\((3*-1) + (1*0) = -3\)</span>. Applying the same rule to the sixth value gives <span class="math inline">\((3*-1) + (1*1)\)</span> which makes -2. The next value has two incidences of the number 2, replacing both with -1 gives <span class="math inline">\((3*-1) + (1*-1)\)</span> is equal to -4. Let’s skip ahead a few numbers to decimal number 18, which in ternary becomes 200, where the first position represents the number 9. Replacing the 2 in this number gives <span class="math inline">\((9*-1) + (3*0) + (1*0)\)</span>, which makes -9. This process is the balanced ternary enumeration.</p>
<p>Just as show of proof, we can also apply the same formula to values that don’t contain a 2, for instance decimal number 10, which becomes 101 in ternary. The formula for this becomes <span class="math inline">\((9*1) + (3*0) + (1*1)\)</span>, which makes again 10.</p>
<p>Let’s put this sequence together:</p>
<p>[0   1   -1   3   4   2   -3   -2   -4   9   10]</p>
<p>And that’s balanced ternary enumeration.</p>
</div>
<div id="coding-the-formula" class="section level3">
<h3>Coding the formula</h3>
<p>So obviously we are lazy, and don’t want to do this process manually for thousands of values. that’s why we’re going to code it. For this step I translated some Python code to R syntax. The function I wrote to do one step of balanced ternary enumartion is shown below. The first value is always 0 (since it’s a 0 in the first position, hence <span class="math inline">\(1*0 = 0\)</span>). After this, we can incorporate the two steps (of converting into ternary and the enumeration) into one. The formula for this looks like this:</p>
<p><span class="math display">\[
\begin{aligned}
a(0) &amp;= 0\\
a(3n) &amp;= 3 * a(n)\\
a(3n + 1) &amp;= 3 * a(n) + 1\\
a(3n + 2) &amp;= 3 * a(n) - 1\\
\end{aligned}
\]</span></p>
<p>The Python code for this function came from a website that collects mathematical functions and sequences and can be found <a href="https://oeis.org/A117966">here</a>. I’ve adapted it to work in R. Since 0 will always result in 0, this is hard coded in. Afterwards it is a nested function (I know, we all love it) where it iteratively calls itself until the input to the function is 0 and it stops. At that point we have out balanced ternary. This function only performs the calculation for one value. So getting a sequence means putting it in a <code>map()</code> function.</p>
<pre class="r"><code>BTE &lt;- function(x) {
  if (x == 0) {
    return(0)
  }
  if (x %% 3 == 0) {
    return(3 * BTE(x / 3))
  } else if (x %% 3 == 1) {
    return(3 * BTE((x - 1) / 3) + 1)
  } else if (x %% 3 == 2) {
    return(3 * BTE((x - 2) / 3) - 1)
  }
}</code></pre>
<p>Let’s go through one iteration of this code. Let’s say <code>x &lt;- 3</code>. 3 modulo 3 is equal to 0, so we enter the first condition. The result of this is 3 multiplied by the outcome of the same function, except the input now is x divided by three, or 3/3, or 1, in our example. This becomes the new input for the function. 1 modulo 3 is equal to 1. So now we enter the second condition. Now the input to the <code>BTE()</code> function is 1 minus 1, divided by 3. This is 0, so we return 3 * 0 + 1, which is equal to 3.</p>
<p>If we plug the number 3 into the formula, we will get the same result:</p>
<pre class="r"><code>BTE(3)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Let’s also look at a few other examples using the <code>map()</code> function again. Since the <code>BTE()</code> function outputs only integers, I use <code>map_dbl()</code>. Let’s input a few exampels:</p>
<pre class="r"><code>example_vector &lt;- c(0,seq(10),500,1500,9999)
map_dbl(example_vector, BTE)</code></pre>
<pre><code>##  [1]    0    1   -1    3    4    2   -3   -2   -4    9   10 -232 -696 9270</code></pre>
<p>This corresponds to the values we created earlier, and the larger numbers make sense also. Okay, let’s now create an entire sequence. We’ll do 59.048 iterations (it’ll become clear later why this specific number). We’ll save the output in a variable called <code>starwars_seq</code> (forgotten yet that this thing started with Star Wars?).</p>
<pre class="r"><code>starwars_seq &lt;- map_dbl(seq(59048), BTE)</code></pre>
</div>
<div id="plotting-the-star-destroyers" class="section level3">
<h3>Plotting the Star Destroyers</h3>
<p>Now, when we plot the values as a scatter plot, it’ll become maybe a bit clearer how this mathematical formula circles back to our Star Wars scene.</p>
<pre class="r"><code>ggplot(data = NULL, aes(x = seq(starwars_seq), y = starwars_seq)) +
  geom_point() +
  theme_minimal()</code></pre>
<p><img src="/blog/2020-plotting-star-destroyers-in-R_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>It’s star destroyers in battle formation! How crazy is that!? It’s such an interesting pattern. You can create as many formations as you like (or as your computer can handle) since the sequence will continue to infinity (it’s like Emperor Palpatine’s wet dream). Another feature of this sequence is that it will return every integer exactly once. We can confirm this property very easily by comparing the number of integers given to the balanced ternary enumeration function and the length of unique values returned:</p>
<pre class="r"><code>length(starwars_seq) == length(unique(starwars_seq))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>The first point of each “squadron” of star destroyers starts with a value that is the same in decimal system as it is in balanced ternary enumeration. Remember the length of the <code>starwars_seq</code> variable was 59 048? I chose that because it would start plotting a new squadron at x = 59 049. Let’s confirm this:</p>
<pre class="r"><code>BTE(59049)</code></pre>
<pre><code>## [1] 59049</code></pre>
<p>There is a range of values where the input of the balanced ternary enumeration is equal to the outcome (or where the outcome is equal to the input divided by two times -1 (<span class="math inline">\(\frac{-x}{2}\)</span>). There’s a clear pattern to these numbers, but I’ve done enough maths for today, so I’ll save it for another time.</p>
<p>Anyway, the plot! It is cool and all, but let’s make it look a bit more like Star Wars by changing some style elements. We’ll also generate some stars. For fun’s sake we’ll also add a planet or moon.</p>
<pre class="r"><code>set.seed(1977)
ggplot(data = NULL, aes(x = seq(starwars_seq), y = starwars_seq)) +
  geom_point(aes(x = sample(seq(-1e4,length(starwars_seq)+1e4), 1e3),
                 y = sample(seq(min(starwars_seq)-1e4,max(starwars_seq)+1e4), 1e3)), 
            shape = 18, size = 1e-5, color = &quot;yellow&quot;) +
  geom_point(aes(x = sample(seq(starwars_seq), 1),
                 y = sample(starwars_seq, 1)), 
            shape = 19, size = 12, color = &quot;darkslategray&quot;) +
  geom_point(size = 4, color = &quot;grey90&quot;) +
  theme_void() +
  theme(panel.background = element_rect(fill = &quot;black&quot;))</code></pre>
<p><img src="/blog/2020-plotting-star-destroyers-in-R_files/figure-html/unnamed-chunk-18-1.png" width="1152" style="display: block; margin: auto;" /></p>
<p>Hope you enjoyed reading about me rambling about maths and implementing these functions to R! I will certainly do another plot some time later!
<br><br></p>
<p><strong>BONUS</strong><br>
We can create another plot (nothing related to Star Wars perhaps), that looks nice also. Now, instead of <code>geom_point()</code> we’ll use <code>geom_line()</code>. No further purpose, just pretty.</p>
<pre class="r"><code>ggplot(data = NULL, aes(x = seq(starwars_seq), y = starwars_seq)) +
  geom_line() + 
  theme_minimal()</code></pre>
<p><img src="/blog/2020-plotting-star-destroyers-in-R_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
